using MathNet.Numerics.Distributions;
using NeatNetwork;
using NeatNetwork.NetworkFiles;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Threading.Tasks;
using System.Windows.Forms;
using static Functionality.ImageProcessing;
using static Functionality.PathGetter;

namespace AbstractVideoGenerator
{
    public partial class MainForm : Form
    {
        private NN autoEncoder, discriminative, generative;

        private List<string[]> imagePaths;
        private List<string> folderNames;
        private List<string> shuffledImages;

        private Timer autoencoderVideoTimer;
        private double[] compressedVideoImage;

        #region Form things

        public MainForm()
        {
            InitializeComponent();
        }

        private void MainForm_Load(object sender, EventArgs e)
        {
        }

        #region Save Load (IO)

        private void saveToFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (autoEncoder == null && discriminative == null)
            {
                MessageBox.Show("Nothing to save (First train or load desired network/s)", "ERROR", MessageBoxButtons.OK);
                return;
            }

            if (MessageBox.Show("Do you wish to save your NN/s?", "", MessageBoxButtons.YesNo) != DialogResult.Yes)
                return;

            SaveFileDialog saveFileDialog = new SaveFileDialog()
            {
                InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                AddExtension = true,
                Filter = "Text files (*.txt)|*.txt",
                Title = "Select name and where you wish to save your networks",
            };

            while (saveFileDialog.ShowDialog() != DialogResult.OK) ;

            var path = saveFileDialog.FileName;
            string str = string.Empty;

            List<Task<string>> strTasks = new List<Task<string>>();
            if (autoEncoder != null && discriminative != null)
            {
                str += "autoencoder Gan";
                strTasks.Add(Task.Run(() => autoEncoder.ToString()));
                strTasks.Add(Task.Run(() => discriminative.ToString()));
                strTasks.Add(Task.Run(() => generative.ToString()));
            }
            else if (autoEncoder != null)
            {
                str += "autoencoder";
                strTasks.Add(Task.Run(() => autoEncoder.ToString()));
            }
            else
            {
                str += "Gan";
                strTasks.Add(Task.Run(() => discriminative.ToString()));
                strTasks.Add(Task.Run(() => generative.ToString()));
            }

            str += "\nJGG\n";

            foreach (var task in strTasks)
            {
                task.Wait();
            }

            foreach (var strTask in strTasks)
            {
                str += strTask.Result;
                str += "\n====\n";
            }
            str = str.Remove(str.LastIndexOf("\n====\n"));

            File.WriteAllText(path, str);
        }

        private void loadFromFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (MessageBox.Show("Do you wish to load NN/s?", "", MessageBoxButtons.YesNo) != DialogResult.Yes)
                return;

            OpenFileDialog openFileDialog = new OpenFileDialog()
            {
                Title = "Select a .txt file generated by this app to load your NNs",
                InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                Filter = "Text files (*.txt)|*.txt",
                Multiselect = false,
            };

            while (openFileDialog.ShowDialog() != DialogResult.OK) ;

            var filePath = openFileDialog.FileName;

            string text = string.Empty;
            using (StreamReader reader = new StreamReader(filePath))
            {
                text = reader.ReadToEnd();
            }

            string[] headerContent = text.Split(new string[] { "\nJGG\n" }, StringSplitOptions.None);
            string header = headerContent[0];
            string content = headerContent[1];

            string[] networkStrs = content.Split(new string[] { "\n====\n" }, StringSplitOptions.None);
            List<Task<NN>> NNTasks = new List<Task<NN>>();

            if (header == "autoencoder Gan")
            {
                NNTasks.Add(Task.Run(() => new NN(networkStrs[0])));
                NNTasks.Add(Task.Run(() => new NN(networkStrs[1])));
                NNTasks.Add(Task.Run(() => new NN(networkStrs[2])));
            }
            else if (header == "autoencoder")
            {
                NNTasks.Add(Task.Run(() => new NN(networkStrs[0])));
            }
            else if (header == "Gan")
            {
                NNTasks.Add(Task.Run(() => new NN(networkStrs[0])));
                NNTasks.Add(Task.Run(() => new NN(networkStrs[1])));
            }
            else
            {
                MessageBox.Show("This file wasn't generated by this app and thus is incompatible.", "Error", MessageBoxButtons.OK);
                return;
            }

            foreach (var networkTask in NNTasks)
            {
                networkTask.Wait();
            }

            if (header == "autoencoder Gan")
            {
                autoEncoder = NNTasks[0].Result;
                discriminative = NNTasks[1].Result;
                generative = NNTasks[2].Result;
            }
            else if (header == "autoencoder")
            {
                autoEncoder = NNTasks[0].Result;
            }
            else
            {
                discriminative = NNTasks[0].Result;
                generative = NNTasks[1].Result;
            }
        }

        #endregion Save Load (IO)

        #region Auto encoder execution

        private void ShowAutoencoderImageBttn_Click(object sender, EventArgs e)
        {
            if (autoencoderVideoTimer != null)
                autoencoderVideoTimer.Stop();

            if (autoEncoder == null)
            {
                MessageBox.Show("First initialize autoencoder network");
                return;
            }

            Bitmap originalImage;
            if (shuffledImages == null)
            {
                string imagePath = GetImagePath();
                if (imagePath == null)
                    return;

                originalImage = new Bitmap(imagePath);
            }
            else
            {
                originalImage = new Bitmap(shuffledImages[new Random(DateTime.Now.Millisecond + rI++).Next(shuffledImages.Count)]);
            }

            int networkOutputSquareSideSize = GetAutoencoderOutputSquareSideSize();

            Bitmap reducedImage = new Bitmap(originalImage, new Size(networkOutputSquareSideSize, networkOutputSquareSideSize));

            double[] X = BitmapToDoubleArray(reducedImage);
            double[] reconstructedImage = autoEncoder.Execute(X);

            Bitmap reconstructedBitmap = DoubleArrayToBitmap(reconstructedImage, networkOutputSquareSideSize, networkOutputSquareSideSize);
            Bitmap augmentedBitmap = new Bitmap(reconstructedBitmap, Display.Size);
            Display.Image = augmentedBitmap;

            originalImage.Dispose();
            reducedImage.Dispose();
            reconstructedBitmap.Dispose();
        }

        private void AutoencoderVideoSelectedImageBttn_Click(object sender, EventArgs e)
        {
            if (autoEncoder == null)
            {
                MessageBox.Show("First you need to train or load an autoencoder network", "ERROR");
                return;
            }

            autoencoderVideoTimer = new Timer()
            {
                Interval = 33
            };

            string imagePath = GetImagePath();
            if (imagePath == null)
                return;

            int networkOutputSquareSideSize = GetAutoencoderOutputSquareSideSize();

            Bitmap bmp = new Bitmap(imagePath);
            Bitmap downscaledBmp = new Bitmap(bmp, networkOutputSquareSideSize, networkOutputSquareSideSize);
            Display.Image = new Bitmap(bmp, Display.Size);

            double[] X = BitmapToDoubleArray(downscaledBmp);
            compressedVideoImage = autoEncoder.ExecuteUpToLayer(X, GetAutoencoderMostCompressedLayer());

            bmp.Dispose();
            downscaledBmp.Dispose();

            autoencoderVideoTimer.Tick += ShowAlteredImage;
            autoencoderVideoTimer.Start();
        }

        private void ShowAlteredImage(object sender, EventArgs e)
        {
            var nOutput = autoEncoder.ExecuteFromLayer(GetAutoencoderMostCompressedLayer(), compressedVideoImage);
            int networkOutputSquareSideSize = GetAutoencoderOutputSquareSideSize();
            Bitmap outputNetworkImage = DoubleArrayToBitmap(nOutput, networkOutputSquareSideSize, networkOutputSquareSideSize);
            Bitmap upscaledBmp = new Bitmap(outputNetworkImage, Display.Size);
            Display.Image.Dispose();
            Display.Image = upscaledBmp;

            outputNetworkImage.Dispose();

            Random r = new Random(DateTime.Now.Millisecond);
            for (int i = 0; i < compressedVideoImage.Length; i++)
            {
                double variation = (r.NextDouble() - .5) / 5;
                compressedVideoImage[i] += variation;
            }
        }

        #endregion Auto encoder execution

        #endregion Form things

        #region functionality

        public static string FolderToName(string folderPath)
        {
            if (folderPath.EndsWith(@"\"))
                folderPath = folderPath.Remove(folderPath.LastIndexOf(@"\"));

            folderPath = folderPath.Remove(0, folderPath.LastIndexOf(@"\") + 1);
            return folderPath;
        }

        private int GetAutoencoderOutputSquareSideSize()
        {
            int output = autoEncoder.Shape[autoEncoder.Shape.Length - 1];
            output /= 3;
            output = Convert.ToInt32(Math.Sqrt(output));
            return output;
        }

        private int GetAutoencoderMostCompressedLayer()
        {
            int autoencoderCompressedLayer = -1;
            int[] autoencoderShape = autoEncoder.Shape;
            int minLayerLength = int.MaxValue;
            for (int i = 1; i < autoEncoder.LayerCount; i++)
                if (autoencoderShape[i] < minLayerLength)
                    autoencoderCompressedLayer = i - 1;
            return autoencoderCompressedLayer;
        }

        #endregion functionality

        #region network things

        public double[] GetGaussianNoise(double mean, double standarDeviation, int arrayLength)
        {
            double[] output = new double[arrayLength];
            Normal normalDistribution = new Normal(mean, standarDeviation);
            for (int i = 0; i < arrayLength; i++)
                output[i] = normalDistribution.Sample();
            return output;
        }

        #endregion network things
    }
}